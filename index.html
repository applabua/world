<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>GOLDEN MILLION — Get in now, be remembered beside legends.</title>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<style>
  :root{ --bg:#fff; --ink:#111; --muted:#6b7280; --line:#e5e7eb; --overlay:rgba(0,0,0,.45); }
  *{box-sizing:border-box}
  html,body{height:100%;margin:0;background:var(--bg);color:var(--ink);font:14px/1.45 system-ui,-apple-system,Segoe UI,Roboto,Arial}
  header{position:fixed;inset:0 0 auto 0;z-index:20;display:flex;justify-content:center;padding:8px 12px;pointer-events:none}
  .cta{pointer-events:auto;display:inline-flex;align-items:center;gap:10px;background:rgba(255,255,255,.96);border:1px solid var(--line);border-radius:999px;padding:8px 14px;box-shadow:0 4px 20px rgba(0,0,0,.06)}
  .dot{width:10px;height:10px;border-radius:50%;background:radial-gradient(#ffd24d,#e1b526)}
  .cta b{font-weight:800}.cta span{color:var(--muted)}
  #field{position:fixed;inset:0;display:block;cursor:crosshair}

  .overlay{position:fixed;inset:0;background:var(--overlay);display:none;align-items:center;justify-content:center;z-index:50}
  .overlay.on{display:flex}
  .card{width:min(720px,92vw);background:#fff;border:1px solid var(--line);border-radius:16px;box-shadow:0 10px 40px rgba(0,0,0,.25);padding:16px;animation:pop .26s ease-out both}
  @keyframes pop{from{transform:scale(.96);opacity:0}to{transform:scale(1);opacity:1}}
  .title{margin:0 0 6px 0;font-weight:800;letter-spacing:.3px}
  .sub{margin:0 0 12px 0;color:var(--muted)}
  .row{display:flex;gap:12px;flex-wrap:wrap}.col{flex:1 1 280px}
  .drop{min-height:140px;border:1px dashed #cfd3da;border-radius:12px;display:flex;align-items:center;justify-content:center;color:#666;padding:10px;text-align:center;background:#fafafa;cursor:pointer}
  .thumb{max-width:100%;max-height:340px;border-radius:12px;border:1px solid var(--line);display:block}
  .input{width:100%;padding:10px 12px;border:1px solid var(--line);border-radius:10px}
  .actions{display:flex;gap:8px;justify-content:flex-end;margin-top:14px}
  .btn{appearance:none;border:1px solid var(--line);background:#fff;color:#111;padding:8px 12px;border-radius:10px;cursor:pointer}
  .btn.primary{border-color:#111;background:#111;color:#fff}
  .range{width:100%}
  .mini{font-size:12px;color:#666}
</style>
</head>
<body>
<header>
  <div class="cta"><div class="dot"></div><b>GOLDEN MILLION</b><span>Get in now — be remembered beside legends.</span></div>
</header>

<canvas id="field"></canvas>

<!-- VIEW (occupied) -->
<div class="overlay" id="viewOverlay">
  <div class="card">
    <h3 class="title" id="viewTitle">Legend</h3>
    <p class="sub" id="viewSub">“A short line for history.”</p>
    <img id="viewImg" class="thumb" alt="">
    <div class="actions"><button class="btn" id="viewClose">Close</button></div>
  </div>
</div>

<!-- ADD (free) -->
<div class="overlay" id="addOverlay">
  <div class="card">
    <h3 class="title">Claim your golden spot — $1 / year (test mode, no payment yet)</h3>
    <p class="sub">Add your image and a short line about yourself. Saved locally in your browser for now.</p>
    <div class="row">
      <div class="col">
        <div class="drop" id="drop"><input type="file" id="file" accept="image/*" style="display:none"><span id="dropText">Drop an image here (or click)</span></div>
        <img id="preview" class="thumb" alt="" style="display:none;margin-top:8px">
      </div>
      <div class="col">
        <label class="sub" for="desc">Your short line (max 80 chars)</label>
        <input class="input" id="desc" maxlength="80" placeholder="I was here. 2025.">
        <label class="sub" for="size">Tile size (cells): <span id="sizeLabel">8×8</span></label>
        <input id="size" class="range" type="range" min="4" max="24" step="1" value="8">
        <div class="mini">Bigger tile = larger image area. Aspect is kept near square; shapes are irregular.</div>
      </div>
    </div>
    <div class="actions"><button class="btn" id="addCancel">Cancel</button><button class="btn primary" id="addSave">Save (test)</button></div>
  </div>
</div>

<script>
/* =========================================================
   GOLDEN MILLION — million-slot canvas (no backend)
   - Base grid: 1000×1000 microcells (1,000,000)
   - Variable-sized "photo tiles" = clusters of microcells (chaotic sizes)
   - 100 biggest clusters prefilled with legends (no Putin)
   - Save user tiles (image+text) into localStorage (image auto-compressed to WebP)
   - Zoom/Pan; irregular masks for photos; initial view shows whole wall
   ========================================================= */

/* ---------- Canvas & world ---------- */
const CAN = document.getElementById('field');
const CTX = CAN.getContext('2d', { alpha:false });
let DPR = Math.max(1, window.devicePixelRatio || 1);

const GRID = { cols:1000, rows:1000, cell:10 };      // 1e6 microcells
const WORLD = { w: GRID.cols*GRID.cell, h: GRID.rows*GRID.cell };
let W=0,H=0, scale=0.12, offX=0, offY=0;

function fit(){
  W = CAN.width = Math.floor(window.innerWidth * DPR);
  H = CAN.height = Math.floor(window.innerHeight * DPR);
  CAN.style.width = window.innerWidth+'px'; CAN.style.height = window.innerHeight+'px';
  const sFit = Math.min(W/WORLD.w, H/WORLD.h);
  if (!fit._done){ scale = sFit * 1.02; offX = (W - WORLD.w*scale)/2; offY = (H - WORLD.h*scale)/2; fit._done = true; }
  draw();
}
window.addEventListener('resize', fit);

/* ---------- Helpers ---------- */
const clamp = (n,a,b)=> Math.max(a, Math.min(b,n));
function worldToScreen(wx,wy){ return [(wx*scale + offX), (wy*scale + offY)]; }
function screenToWorld(sx,sy){ return [(sx - offX)/scale, (sy - offY)/scale]; }
function seededRand(seed){ let x = seed|0; x^=x<<13; x^=x>>>17; x^=x<<5; return (x>>>0)/4294967296; }

/* ---------- Storage (local) ---------- */
const LS_KEY = "golden_million_tiles_v3";
let tiles = [];           // [{id,type,x,y,w,h,img,desc,name,seed}]
let occ = new Map();      // "x_y" -> tileId
try{ const raw = localStorage.getItem(LS_KEY); if (raw) tiles = JSON.parse(raw); }catch(e){ tiles=[]; }
rebuildOcc();

/* ---------- Legends (100 largest) ---------- */
const LEGEND_NAMES = [
  "Abraham Lincoln","Nelson Mandela","Mahatma Gandhi","Martin Luther King Jr.","Winston Churchill",
  "Volodymyr Zelenskyy","George Washington","Napoleon Bonaparte","Julius Caesar","Cleopatra",
  "Leonardo da Vinci","Michelangelo","Vincent van Gogh","Pablo Picasso","Frida Kahlo",
  "Albert Einstein","Isaac Newton","Galileo Galilei","Nikola Tesla","Marie Curie",
  "Ada Lovelace","Alan Turing","Grace Hopper","Katherine Johnson","Hedy Lamarr",
  "Charles Darwin","Carl Sagan","Richard Feynman","Johannes Kepler","Niels Bohr",
  "William Shakespeare","Homer","Dante Alighieri","Johann S. Bach","Ludwig van Beethoven",
  "Wolfgang A. Mozart","Leo Tolstoy","Fyodor Dostoevsky","Ernest Hemingway","Agatha Christie",
  "Elon Musk","Steve Jobs","Bill Gates","Jeff Bezos","Warren Buffett",
  "Donald Trump","Barack Obama","Joe Biden","Angela Merkel","Emmanuel Macron",
  "Serena Williams","Michael Jordan","Kobe Bryant","Lionel Messi","Cristiano Ronaldo",
  "Pelé","Usain Bolt","Bruce Lee","Jackie Chan","Hayao Miyazaki",
  "Akira Kurosawa","Steven Spielberg","George Lucas","Quentin Tarantino","James Cameron",
  "Mother Teresa","Florence Nightingale","Yayoi Kusama","Banksy","Salvador Dalí",
  "Socrates","Plato","Aristotle","Confucius","Sun Tzu",
  "Genghis Khan","Alexander the Great","Queen Elizabeth II","Joan of Arc","Catherine the Great",
  "Sheryl Sandberg","Satya Nadella","Sundar Pichai","Tim Cook","Susan Wojcicki",
  "Desmond Tutu","Lech Wałęsa","Václav Havel","Stephen Hawking","Jane Goodall",
  "Neil Armstrong","Yuri Gagarin","Amelia Earhart","J.R.R. Tolkien","George R. R. Martin",
  "J.K. Rowling","Haruki Murakami","Gabriel García Márquez","Oprah Winfrey","Greta Thunberg"
];

function svgPortrait(name){
  const initials = name.split(/\s+/).map(w=>w[0]).slice(0,2).join('').toUpperCase();
  const esc = s=>encodeURIComponent(s);
  const svg =
`<svg xmlns='http://www.w3.org/2000/svg' width='800' height='800'>
  <defs><linearGradient id='g' x1='0' y1='0' x2='0' y2='1'>
    <stop offset='0%' stop-color='#f9e9a3'/><stop offset='50%' stop-color='#f0d16a'/><stop offset='100%' stop-color='#cda434'/>
  </linearGradient></defs>
  <rect width='100%' height='100%' fill='url(#g)'/>
  <circle cx='400' cy='330' r='180' fill='rgba(255,255,255,.25)'/>
  <text x='400' y='380' font-family='system-ui,Arial' font-size='160' text-anchor='middle' fill='#222' font-weight='800'>${initials}</text>
  <text x='400' y='720' font-family='system-ui,Arial' font-size='42' text-anchor='middle' fill='#222' font-weight='700'>${name.replace(/&/g,"&amp;")}</text>
</svg>`;
  return "data:image/svg+xml;utf8,"+esc(svg);
}

/* Place 100 big legend tiles (if not already saved) */
if (!tiles.some(t=>t.type==="legend")){
  const placed = [];
  let tries=0, i=0;
  while(i<LEGEND_NAMES.length && tries<200000){
    tries++;
    // sizes (in microcells): legends — большие, «не вытянутые»
    const w = Math.floor( seededRand(1000+i)* (24-16) + 16 ); // 16..24
    const hBase = Math.floor(w * (0.85 + seededRand(2000+i)*0.3)); // 0.85..1.15 * w
    const h = clamp(hBase, 14, 26);
    const x = Math.floor(Math.random()*(GRID.cols - w - 2)) + 1;
    const y = Math.floor(Math.random()*(GRID.rows - h - 2)) + 1;
    if (collides(x,y,w,h)) continue;
    const name = LEGEND_NAMES[i];
    const id = "legend_"+i;
    const t = { id, type:"legend", x,y,w,h, name, desc:"Part of the Golden Million.", img: svgPortrait(name), seed: (i+1)*99991 };
    tiles.push(t);
    occupy(id,x,y,w,h);
    i++;
  }
  persist();
}

/* ---------- Drawing ---------- */
function draw(){
  CTX.setTransform(1,0,0,1,0,0);
  CTX.fillStyle="#fff"; CTX.fillRect(0,0,W,H);

  const [wx0, wy0] = screenToWorld(0,0);
  const [wx1, wy1] = screenToWorld(W,H);
  const minX = clamp(Math.floor(wx0/GRID.cell)-2,0,GRID.cols-1);
  const minY = clamp(Math.floor(wy0/GRID.cell)-2,0,GRID.rows-1);
  const maxX = clamp(Math.floor(wx1/GRID.cell)+2,0,GRID.cols-1);
  const maxY = clamp(Math.floor(wy1/GRID.cell)+2,0,GRID.rows-1);

  // grid lines (light)
  CTX.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--line').trim() || '#e5e7eb';
  CTX.lineWidth = Math.max(1, 0.5*DPR);
  CTX.beginPath();
  for(let y=minY; y<=maxY; y++){
    const [sx0, sy] = worldToScreen(minX*GRID.cell, y*GRID.cell);
    const [sx1, ]  = worldToScreen((maxX+1)*GRID.cell, y*GRID.cell);
    CTX.moveTo(sx0,sy); CTX.lineTo(sx1,sy);
  }
  for(let x=minX; x<=maxX; x++){
    const [sx, sy0] = worldToScreen(x*GRID.cell, minY*GRID.cell);
    const [, sy1]   = worldToScreen(x*GRID.cell, (maxY+1)*GRID.cell);
    CTX.moveTo(sx,sy0); CTX.lineTo(sx,sy1);
  }
  CTX.stroke();

  // draw tiles (only those intersecting viewport)
  const sPix = scale*GRID.cell;
  const viewTiles = tiles.filter(t => rectsIntersect(
    t.x*GRID.cell, t.y*GRID.cell, t.w*GRID.cell, t.h*GRID.cell,
    wx0, wy0, wx1-wx0, wy1-wy0
  ));
  for(const t of viewTiles){
    const [sx,sy] = worldToScreen(t.x*GRID.cell, t.y*GRID.cell);
    const sw = t.w*GRID.cell*scale, sh = t.h*GRID.cell*scale;
    // irregular mask
    CTX.save(); CTX.translate(sx,sy); CTX.scale(scale,scale);
    beginIrregularPath(t.x,t.y,t.w,t.h,t.seed); CTX.clip();
    drawImageCover(t.img, 0,0, t.w*GRID.cell, t.h*GRID.cell);
    CTX.restore();

    // outline at big zoom
    if (sPix > 14){
      CTX.save(); CTX.translate(sx,sy); CTX.scale(scale,scale);
      CTX.lineWidth = Math.max(1, 0.7*DPR);
      CTX.strokeStyle = '#d0d4dc';
      beginIrregularPath(t.x,t.y,t.w,t.h,t.seed); CTX.stroke();
      CTX.restore();
    }
  }
}

function beginIrregularPath(x,y,w,h,seed){
  const s = GRID.cell;
  const id = (x*73856093 ^ y*19349663 ^ (seed||1)) >>> 0;
  const rnd = k => seededRand(id + k);
  const j = 0.22*s; // jitter per segment
  const stepsX = Math.max(4, Math.floor(w/4));
  const stepsY = Math.max(4, Math.floor(h/4));
  CTX.beginPath();
  // top
  for(let i=0;i<=stepsX;i++){
    const px = x*s + (i/stepsX)*w*s;
    const py = y*s + (rnd(i)*j);
    (i===0) ? CTX.moveTo(px,py) : CTX.lineTo(px,py);
  }
  // right
  for(let i=1;i<=stepsY;i++){
    const px = (x+w)*s - (rnd(i+11)*j);
    const py = y*s + (i/stepsY)*h*s;
    CTX.lineTo(px,py);
  }
  // bottom
  for(let i=1;i<=stepsX;i++){
    const px = (x+w)*s - (i/stepsX)*w*s;
    const py = (y+h)*s - (rnd(i+23)*j);
    CTX.lineTo(px,py);
  }
  // left
  for(let i=1;i<=stepsY;i++){
    const px = x*s + (rnd(i+37)*j);
    const py = (y+h)*s - (i/stepsY)*h*s;
    CTX.lineTo(px,py);
  }
  CTX.closePath();
}

const imgCache = new Map();
function loadImg(src){
  if (imgCache.has(src)) return imgCache.get(src);
  const p = new Promise((res,rej)=>{ const im=new Image(); im.crossOrigin="anonymous"; im.onload=()=>res(im); im.onerror=rej; im.src=src; });
  imgCache.set(src,p); return p;
}
async function drawImageCover(src,x,y,w,h){
  try{
    const im = await loadImg(src);
    const r = Math.max(w/im.width, h/im.height);
    const iw = im.width*r, ih = im.height*r;
    const ix = x + (w - iw)/2, iy = y + (h - ih)/2;
    CTX.fillStyle="#fff"; CTX.fillRect(x,y,w,h);
    CTX.drawImage(im, ix, iy, iw, ih);
  }catch(e){}
}

/* ---------- Geometry/occupancy ---------- */
function rectsIntersect(ax,ay,aw,ah, bx,by,bw,bh){
  return ax < bx + bw && ax + aw > bx && ay < by + bh && ay + ah > by;
}
function collides(x,y,w,h){
  for(let yy=y; yy<y+h; yy++){
    for(let xx=x; xx<x+w; xx++){
      if (occ.has(xx+"_"+yy)) return true;
    }
  }
  return false;
}
function occupy(id,x,y,w,h){
  for(let yy=y; yy<y+h; yy++){
    for(let xx=x; xx<x+w; xx++){
      occ.set(xx+"_"+yy, id);
    }
  }
}
function freeRegion(x,y,w,h){
  for(let yy=y; yy<y+h; yy++){
    for(let xx=x; xx<x+w; xx++){
      occ.delete(xx+"_"+yy);
    }
  }
}
function rebuildOcc(){
  occ.clear();
  for(const t of tiles) occupy(t.id,t.x,t.y,t.w,t.h);
}

/* ---------- Interactions ---------- */
let dragging=false, sx=0, sy=0, ox=0, oy=0;
CAN.addEventListener('mousedown',e=>{ dragging=true; sx=e.clientX; sy=e.clientY; ox=offX; oy=offY; });
window.addEventListener('mouseup',()=> dragging=false);
window.addEventListener('mousemove',e=>{ if(dragging){ offX = ox + (e.clientX - sx)*DPR; offY = oy + (e.clientY - sy)*DPR; draw(); }});
CAN.addEventListener('wheel',e=>{
  e.preventDefault();
  const delta = Math.sign(e.deltaY)*-0.08;
  const rect = CAN.getBoundingClientRect();
  const cx = (e.clientX-rect.left)*DPR, cy=(e.clientY-rect.top)*DPR;
  const [wx,wy] = screenToWorld(cx,cy);
  scale = clamp(scale+delta, 0.06, 3);
  offX = cx - wx*scale; offY = cy - wy*scale;
  draw();
},{passive:false});

CAN.addEventListener('click',(e)=>{
  const rect = CAN.getBoundingClientRect();
  const [wx, wy] = screenToWorld((e.clientX-rect.left)*DPR,(e.clientY-rect.top)*DPR);
  const cx = clamp(Math.floor(wx/GRID.cell),0,GRID.cols-1);
  const cy = clamp(Math.floor(wy/GRID.cell),0,GRID.rows-1);
  const id = occ.get(cx+"_"+cy);
  if (id){
    const t = tiles.find(t=>t.id===id);
    openView(t);
  } else {
    openAdd(cx,cy);
  }
});

/* ---------- View modal ---------- */
const viewOverlay = document.getElementById('viewOverlay');
const viewImg = document.getElementById('viewImg');
const viewTitle = document.getElementById('viewTitle');
const viewSub = document.getElementById('viewSub');
document.getElementById('viewClose').onclick = ()=> viewOverlay.classList.remove('on');
viewOverlay.addEventListener('click',e=>{ if(e.target===viewOverlay) viewOverlay.classList.remove('on'); });

function openView(t){
  viewTitle.textContent = t.name || "Member of the Golden Million";
  viewSub.textContent = t.desc || "“A short line for history.”";
  viewImg.src = t.img;
  viewOverlay.classList.add('on');
}

/* ---------- Add modal ---------- */
const addOverlay = document.getElementById('addOverlay');
const addCancel  = document.getElementById('addCancel');
const addSave    = document.getElementById('addSave');
const drop       = document.getElementById('drop');
const file       = document.getElementById('file');
const preview    = document.getElementById('preview');
const dropText   = document.getElementById('dropText');
const desc       = document.getElementById('desc');
const sizeRange  = document.getElementById('size');
const sizeLabel  = document.getElementById('sizeLabel');

let addAnchor = {x:0,y:0};
sizeRange.addEventListener('input', ()=> sizeLabel.textContent = sizeRange.value+"×"+sizeRange.value);

drop.addEventListener('click', ()=> file.click());
drop.addEventListener('dragover',e=>{ e.preventDefault(); drop.style.borderColor="#999"; });
drop.addEventListener('dragleave',()=>{ drop.style.borderColor="#cfd3da"; });
drop.addEventListener('drop',e=>{
  e.preventDefault(); drop.style.borderColor="#cfd3da";
  if (e.dataTransfer.files && e.dataTransfer.files[0]) handleFile(e.dataTransfer.files[0]);
});
file.addEventListener('change',e=>{ if (e.target.files && e.target.files[0]) handleFile(e.target.files[0]); });
function handleFile(f){
  if(!/^image\//.test(f.type)) return alert("Please choose an image");
  const r=new FileReader(); r.onload=()=>{ preview.src=r.result; preview.style.display='block'; dropText.textContent="Image selected"; }; r.readAsDataURL(f);
}

addCancel.onclick = ()=> addOverlay.classList.remove('on');
addOverlay.addEventListener('click',e=>{ if(e.target===addOverlay) addOverlay.classList.remove('on'); });

function openAdd(x,y){
  addAnchor = {x,y};
  preview.style.display='none'; preview.src=''; dropText.textContent="Drop an image here (or click)";
  desc.value=""; sizeRange.value=8; sizeLabel.textContent="8×8";
  addOverlay.classList.add('on');
}

addSave.onclick = async ()=>{
  if (!preview.src) return alert("Please add an image first.");
  const text = (desc.value||"I was here.").slice(0,80);
  const side = parseInt(sizeRange.value,10);
  // find nearest free region around anchor
  const pos = findSpotNear(addAnchor.x, addAnchor.y, side, side);
  if (!pos){ alert("No free space nearby — zoom/pan and click another free area."); return; }
  // compress image to WebP (keeps storage small)
  const compressed = await downscaleToWebP(preview.src, side*96); // ~96px per cell side for quality
  const id = "u_"+Date.now()+"_"+Math.random().toString(36).slice(2);
  const t = { id, type:"user", x:pos.x, y:pos.y, w:side, h:side, img: compressed, name:"Golden Million Member", desc:text, seed: (pos.x*911 + pos.y*613) };
  tiles.push(t); occupy(id, t.x,t.y,t.w,t.h);
  persist();
  addOverlay.classList.remove('on');
  draw();
};

function findSpotNear(cx,cy,w,h){
  const maxR = 200; // scan radius in cells
  for (let r=0; r<maxR; r+=2){
    const x0 = clamp(cx - r, 0, GRID.cols - w);
    const y0 = clamp(cy - r, 0, GRID.rows - h);
    const x1 = clamp(cx + r, 0, GRID.cols - w);
    const y1 = clamp(cy + r, 0, GRID.rows - h);
    for (let y=y0; y<=y1; y+=2){
      for (let x=x0; x<=x1; x+=2){
        if (!collides(x,y,w,h)) return {x,y};
      }
    }
  }
  return null;
}

function persist(){
  try{ localStorage.setItem(LS_KEY, JSON.stringify(tiles)); }
  catch(e){ alert("Storage quota exceeded. Image too large. Try a smaller image."); }
}

/* Downscale to WebP (keeps <~200KB) */
async function downscaleToWebP(dataURL, targetPx=768){
  const img = await loadImg(dataURL);
  const maxSide = Math.max(img.width, img.height);
  const scale = Math.min(1, targetPx / maxSide);
  const w = Math.max(64, Math.round(img.width * scale));
  const h = Math.max(64, Math.round(img.height * scale));
  const c = document.createElement('canvas'); c.width=w; c.height=h;
  const c2 = c.getContext('2d'); c2.imageSmoothingEnabled=true; c2.imageSmoothingQuality='high';
  c2.drawImage(img, 0,0,w,h);
  // prefer WebP; fallback to JPEG
  let out = c.toDataURL('image/webp', 0.85);
  if (out.length > 4_500_000) out = c.toDataURL('image/jpeg', 0.85);
  return out;
}

/* ---------- Go ---------- */
fit(); draw();
</script>
</body>
</html>
