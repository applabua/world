<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>GOLDEN MILLION — Get in now, be remembered beside legends.</title>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<style>
  :root{
    --bg:#fff; --ink:#111; --muted:#6b7280; --grid:#e6e9ef; --tile:#222; --overlay:rgba(0,0,0,.5);
  }
  *{box-sizing:border-box}
  html,body{height:100%;margin:0;background:var(--bg);color:var(--ink);font:14px/1.45 system-ui,-apple-system,Segoe UI,Roboto,Arial}
  header{position:fixed;inset:0 0 auto 0;z-index:20;display:flex;justify-content:center;padding:8px 12px;pointer-events:none}
  .cta{pointer-events:auto;display:inline-flex;align-items:center;gap:10px;background:rgba(255,255,255,.96);border:1px solid #e7ebf2;border-radius:999px;padding:8px 14px;box-shadow:0 4px 20px rgba(0,0,0,.06)}
  .dot{width:10px;height:10px;border-radius:50%;background:radial-gradient(#ffd24d,#e1b526)}
  .cta b{font-weight:800}.cta span{color:var(--muted)}
  /* Stage + world (zoom/pan) */
  #stage{position:fixed;inset:0;overflow:hidden;background:
    linear-gradient(var(--grid) 1px, transparent 1px),
    linear-gradient(90deg, var(--grid) 1px, transparent 1px);
    background-size: 32px 32px, 32px 32px;  /* видимая «миллионная» сетка */
  }
  #world{position:absolute; left:0; top:0; transform-origin:0 0; cursor:grab}
  #world.dragging{cursor:grabbing}
  /* Tile = одна «клетка» мозаики */
  .tile{
    position:absolute; border:2px solid var(--tile); background:#fff; overflow:hidden; border-radius:2px;
  }
  .tile img{width:100%; height:100%; object-fit:cover; display:block}
  .tile .caption{
    position:absolute; left:0; right:0; bottom:0;
    background:linear-gradient(180deg, rgba(0,0,0,.0), rgba(0,0,0,.55));
    color:#fff; font-size:12px; padding:6px 8px; line-height:1.2;
    display:flex; justify-content:space-between; gap:8px;
  }
  .tile .caption b{font-weight:700}
  /* Overlays / modals */
  .overlay{position:fixed; inset:0; display:none; align-items:center; justify-content:center; background:var(--overlay); z-index:50}
  .overlay.on{display:flex}
  .card{width:min(760px,92vw); background:#fff; border:1px solid #e7ebf2; border-radius:16px; padding:16px; box-shadow:0 18px 60px rgba(0,0,0,.35); animation:pop .22s ease-out both}
  @keyframes pop{from{transform:scale(.96);opacity:0}to{transform:scale(1);opacity:1}}
  .title{margin:0 0 8px 0; font-weight:800}
  .sub{margin:0 0 12px 0; color:var(--muted)}
  .row{display:flex; gap:12px; flex-wrap:wrap}
  .col{flex:1 1 280px}
  .drop{min-height:160px; border:1px dashed #cfd3da; border-radius:12px; display:flex; align-items:center; justify-content:center; color:#666; background:#fafafa; cursor:pointer}
  .thumb{max-width:100%; max-height:340px; border-radius:12px; border:1px solid #e7ebf2; display:block}
  .input{width:100%; padding:10px 12px; border:1px solid #e7ebf2; border-radius:10px}
  .actions{display:flex; gap:8px; justify-content:flex-end; margin-top:14px}
  .btn{appearance:none; border:1px solid #e7ebf2; background:#fff; color:#111; padding:8px 12px; border-radius:10px; cursor:pointer}
  .btn.primary{border-color:#111; background:#111; color:#fff}
  .mini{font-size:12px; color:#666}
</style>
</head>
<body>
<header>
  <div class="cta"><div class="dot"></div><b>GOLDEN MILLION</b><span>Get in now — be remembered beside legends.</span></div>
</header>

<div id="stage">
  <div id="world"></div>
</div>

<!-- View modal -->
<div class="overlay" id="viewOverlay">
  <div class="card">
    <h3 class="title" id="viewTitle">Legend</h3>
    <p class="sub" id="viewSub">“A short line for history.”</p>
    <img id="viewImg" class="thumb" alt="">
    <div class="actions"><button class="btn" id="viewClose">Close</button></div>
  </div>
</div>

<!-- Add modal -->
<div class="overlay" id="addOverlay">
  <div class="card">
    <h3 class="title">Claim your golden spot — $1 / year (test mode)</h3>
    <p class="sub">Add your image and a short line about yourself. Saved locally in your browser for now.</p>
    <div class="row">
      <div class="col">
        <div class="drop" id="drop">
          <input type="file" id="file" accept="image/*" style="display:none">
          <span id="dropText">Drop an image here (or click)</span>
        </div>
        <img id="preview" class="thumb" alt="" style="display:none; margin-top:8px">
      </div>
      <div class="col">
        <label class="sub" for="desc">Your short line (max 80 chars)</label>
        <input class="input" id="desc" maxlength="80" placeholder="I was here. 2025.">
        <p class="mini">Tiles have different sizes. Double-click a tile to zoom to it; drag to pan, wheel to zoom.</p>
      </div>
    </div>
    <div class="actions"><button class="btn" id="addCancel">Cancel</button><button class="btn primary" id="addSave">Save (test)</button></div>
  </div>
</div>

<script>
/* ======================= core config ======================= */
const CELLS_X = 1000, CELLS_Y = 1000;        // «миллион» фоновых ячеек (визуально — сетка)
const WORLD_W = 8000, WORLD_H = 4800;        // размер «стены» в px (до масштабирования)
const TILES_COUNT = 1000;                    // прямоугольников в мозаике
const LEGENDS_COUNT = 100;                   // топ-100 самых больших под легенды
const SEED = 1337;                           // фиксированный seed для стабильной мозаики

/* ==================== util (seeded random) ==================== */
let _seed = SEED>>>0;
function srand(){ _seed = (_seed*1664525 + 1013904223)>>>0; return _seed/4294967296; }
function randInt(a,b){ return Math.floor(a + srand()*(b-a+1)); }

/* ===================== build random tiling ===================== */
function rect(x,y,w,h){ return {x,y,w,h, area:w*h, id:0}; }
function splitOne(r){
  // сплитим вдоль длинной стороны, но не по центру и с минимальными полями
  const horiz = r.w >= r.h;
  if (horiz){
    const min = Math.max(80, Math.floor(r.w*0.32));
    const max = Math.min(r.w-80, Math.floor(r.w*0.68));
    if (max<=min) return [r];
    const cut = randInt(min,max);
    return [ rect(r.x, r.y, cut, r.h), rect(r.x+cut, r.y, r.w-cut, r.h) ];
  } else {
    const min = Math.max(80, Math.floor(r.h*0.32));
    const max = Math.min(r.h-80, Math.floor(r.h*0.68));
    if (max<=min) return [r];
    const cut = randInt(min,max);
    return [ rect(r.x, r.y, r.w, cut), rect(r.x, r.y+cut, r.w, r.h-cut) ];
  }
}
function buildTiling(n){
  const list = [ rect(0,0, WORLD_W, WORLD_H) ];
  while (list.length < n){
    // выбираем самый большой, который ещё можно резать
    let idx=-1, best=-1;
    for (let i=0;i<list.length;i++){
      const r = list[i];
      if ((r.w>160 && r.h>160) && r.area>best){ best=r.area; idx=i; }
    }
    if (idx===-1) break;
    const r = list.splice(idx,1)[0];
    const [a,b] = splitOne(r);
    if (b){ a.area=a.w*a.h; b.area=b.w*b.h; list.push(a,b); } else list.push(r);
  }
  // убираем чересчур вытянутые доп.сплитом
  for (let k=0;k<list.length;k++){
    const r = list[k], asp=r.w/r.h;
    if (asp>2.6 || asp<0.4){
      const pair = splitOne(r);
      if (pair.length===2){ list.splice(k,1,pair[0],pair[1]); k--; }
    }
  }
  while(list.length>n) list.pop();
  list.forEach((r,i)=> r.id=i);
  return list;
}
const layout = buildTiling(TILES_COUNT);

/* ======================= legends dataset ======================= */
const LEGEND_PHOTOS = {
  "Napoleon Bonaparte":"https://upload.wikimedia.org/wikipedia/commons/5/50/Napoleon_Bonaparte_by_Jean-Auguste-Dominique_Ingres%2C_1806.jpg",
  "Donald Trump":"https://upload.wikimedia.org/wikipedia/commons/5/56/Donald_Trump_official_portrait.jpg",
  "Volodymyr Zelenskyy":"https://upload.wikimedia.org/wikipedia/commons/2/2e/Volodymyr_Zelensky_Official_portrait.jpg",
  "Elon Musk":"https://upload.wikimedia.org/wikipedia/commons/4/49/Elon_Musk_2015.jpg",
  "George Washington":"https://upload.wikimedia.org/wikipedia/commons/6/6f/George_Washington_by_Gilbert_Stuart%2C_1797.jpg",
  "Abraham Lincoln":"https://upload.wikimedia.org/wikipedia/commons/a/a4/Abraham_Lincoln_O-116_by_Gardner%2C_1865-crop.png",
  "Albert Einstein":"https://upload.wikimedia.org/wikipedia/commons/d/d3/Albert_Einstein_Head.jpg",
  "Leonardo da Vinci":"https://upload.wikimedia.org/wikipedia/commons/6/6d/Leonardo_self.jpg",
  "Marie Curie":"https://upload.wikimedia.org/wikipedia/commons/7/7e/Marie_Curie_c1920.jpg",
  "Nikola Tesla":"https://upload.wikimedia.org/wikipedia/commons/d/d4/N.Tesla.JPG",
  "Mahatma Gandhi":"https://upload.wikimedia.org/wikipedia/commons/d/d1/Portrait_Gandhi.jpg",
  "Martin Luther King Jr.":"https://upload.wikimedia.org/wikipedia/commons/a/a3/Martin_Luther_King_Jr_NYWTS_6.jpg",
  "Winston Churchill":"https://upload.wikimedia.org/wikipedia/commons/1/1e/Sir_Winston_Churchill_-_19086236948.jpg",
  "Cleopatra":"https://upload.wikimedia.org/wikipedia/commons/2/2b/Cleopatra_VII_%28Altes_Museum%29.jpg",
  "Steve Jobs":"https://upload.wikimedia.org/wikipedia/commons/8/80/Steve_Jobs_Headshot_2010-CROP2.jpg",
  "Bill Gates":"https://upload.wikimedia.org/wikipedia/commons/a/a0/Bill_Gates_2018.jpg",
  "Jeff Bezos":"https://upload.wikimedia.org/wikipedia/commons/3/35/Jeff_Bezos_cropped.jpg",
  "Barack Obama":"https://upload.wikimedia.org/wikipedia/commons/8/8d/President_Barack_Obama.jpg",
  "Joe Biden":"https://upload.wikimedia.org/wikipedia/commons/6/68/Joe_Biden_presidential_portrait.jpg",
  "Angela Merkel":"https://upload.wikimedia.org/wikipedia/commons/b/bb/Angela_Merkel_Juli_2010_-_3zu4.jpg"
  // остальные легенды автоматически получат аватар-инициалы
};
const LEGEND_NAMES = Object.keys(LEGEND_PHOTOS).concat([
  "Nelson Mandela","Julius Caesar","Pablo Picasso","Vincent van Gogh","Michelangelo",
  "Ada Lovelace","Alan Turing","Grace Hopper","Katherine Johnson","Hedy Lamarr",
  "Charles Darwin","Carl Sagan","Johannes Kepler","Niels Bohr","William Shakespeare",
  "Homer","Dante Alighieri","Johann Sebastian Bach","Ludwig van Beethoven","Wolfgang Amadeus Mozart",
  "Leo Tolstoy","Fyodor Dostoevsky","Ernest Hemingway","Agatha Christie","Serena Williams",
  "Michael Jordan","Kobe Bryant","Lionel Messi","Cristiano Ronaldo","Pelé",
  "Usain Bolt","Bruce Lee","Jackie Chan","Hayao Miyazaki","Akira Kurosawa",
  "Steven Spielberg","George Lucas","Quentin Tarantino","James Cameron","Mother Teresa",
  "Florence Nightingale","Yayoi Kusama","Banksy","Salvador Dalí","Socrates",
  "Plato","Aristotle","Confucius","Sun Tzu","Genghis Khan",
  "Alexander the Great","Queen Elizabeth II","Joan of Arc","Catherine the Great","Sheryl Sandberg",
  "Satya Nadella","Sundar Pichai","Tim Cook","Susan Wojcicki","Desmond Tutu",
  "Lech Wałęsa","Václav Havel","Stephen Hawking","Jane Goodall","Neil Armstrong",
  "Yuri Gagarin","Amelia Earhart","J.R.R. Tolkien","George R. R. Martin","J.K. Rowling",
  "Haruki Murakami","Gabriel García Márquez","Oprah Winfrey","Greta Thunberg","Galileo Galilei"
]).slice(0,LEGENDS_COUNT);

/* ============= local storage for user images ============= */
const LS_KEY = "gm_rect_claims_v1";
let claims = {}; // rectId -> {img, name, desc, legend?}
try{ claims = JSON.parse(localStorage.getItem(LS_KEY)||"{}"); }catch(e){ claims = {}; }
function persist(){ try{ localStorage.setItem(LS_KEY, JSON.stringify(claims)); }catch(e){ alert("Storage quota exceeded. Try a smaller image."); }}

/* ============== render HTML rectangles (no canvas) ============== */
const world = document.getElementById('world');
world.style.width = WORLD_W + 'px';
world.style.height = WORLD_H + 'px';

function initialsAvatar(name,w,h){
  const init = name.split(/\s+/).map(s=>s[0]).slice(0,2).join('').toUpperCase();
  const svg = `
  <svg xmlns='http://www.w3.org/2000/svg' width='${w}' height='${h}'>
    <defs><linearGradient id='g' x1='0' y1='0' x2='0' y2='1'>
      <stop offset='0%' stop-color='#fff2b2'/><stop offset='100%' stop-color='#e4c45e'/>
    </linearGradient></defs>
    <rect width='100%' height='100%' fill='url(#g)'/>
    <text x='50%' y='50%' dominant-baseline='middle' text-anchor='middle'
          font-family='system-ui,Arial' font-size='${Math.floor(Math.min(w,h)*0.35)}'
          font-weight='800' fill='#111'>${init}</text>
  </svg>`;
  return 'data:image/svg+xml;utf8,' + encodeURIComponent(svg);
}

function fillLegends(){
  // выбрать 100 самых больших прямоугольников
  const sorted = [...layout].sort((a,b)=>b.area-a.area).slice(0, LEGENDS_COUNT);
  for (let i=0;i<sorted.length;i++){
    const r = sorted[i];
    if (claims[r.id] && claims[r.id].legend) continue;
    const name = LEGEND_NAMES[i] || "Legend";
    const url = LEGEND_PHOTOS[name];
    claims[r.id] = {
      img: url || initialsAvatar(name, Math.max(200,Math.floor(r.w)), Math.max(200,Math.floor(r.h))),
      name, desc: "Part of the Golden Million.", legend:true
    };
  }
  persist();
}

function drawDOM(){
  world.innerHTML = '';
  for (const r of layout){
    const d = document.createElement('div');
    d.className = 'tile';
    d.style.left = r.x + 'px';
    d.style.top = r.y + 'px';
    d.style.width = r.w + 'px';
    d.style.height = r.h + 'px';
    d.dataset.id = r.id;
    const claim = claims[r.id];
    if (claim){
      const img = document.createElement('img');
      img.alt = claim.name || 'Member';
      img.src = claim.img;
      img.referrerPolicy = 'no-referrer';
      img.onerror = ()=>{ img.src = initialsAvatar(claim.name||'Member', Math.max(200,Math.floor(r.w)), Math.max(200,Math.floor(r.h))); };
      d.appendChild(img);

      const cap = document.createElement('div'); cap.className='caption';
      const left = document.createElement('b'); left.textContent = (claim.name||'Member');
      const right = document.createElement('span'); right.textContent = (claim.desc||'');
      cap.appendChild(left); cap.appendChild(right);
      d.appendChild(cap);
    }
    d.addEventListener('click', onTileClick);
    world.appendChild(d);
  }
}

/* ============== interactions: zoom/pan/click ============== */
let scale = 1, offsetX = 0, offsetY = 0;
(function initTransform(){
  const sFit = Math.min(window.innerWidth / WORLD_W, window.innerHeight / WORLD_H);
  scale = sFit * 1.02;
  setTransform();
})();
function setTransform(){ world.style.transform = `translate(${offsetX}px, ${offsetY}px) scale(${scale})`; }

let dragging=false, sx=0, sy=0, ox=0, oy=0;
world.addEventListener('mousedown', e=>{ dragging=true; world.classList.add('dragging'); sx=e.clientX; sy=e.clientY; ox=offsetX; oy=offsetY; });
window.addEventListener('mouseup', ()=>{ dragging=false; world.classList.remove('dragging'); });
window.addEventListener('mousemove', e=>{ if(!dragging) return; offsetX = ox + (e.clientX - sx); offsetY = oy + (e.clientY - sy); setTransform(); });
document.getElementById('stage').addEventListener('wheel', e=>{
  e.preventDefault();
  const rect = world.getBoundingClientRect();
  const cx = e.clientX - rect.left, cy = e.clientY - rect.top;
  const delta = Math.sign(e.deltaY) * -0.08;
  const ns = Math.min(3, Math.max(0.08, scale + delta));
  // масштаб относительно точки под курсором
  offsetX = e.clientX - (cx * ns);
  offsetY = e.clientY - (cy * ns);
  scale = ns; setTransform();
},{passive:false});

document.getElementById('stage').addEventListener('dblclick', e=>{
  const el = e.target.closest('.tile'); if(!el) return;
  const r = el.getBoundingClientRect();
  const cx = r.left + r.width/2, cy = r.top + r.height/2;
  const ns = Math.min(2.2, Math.max(0.3, Math.min(window.innerWidth/r.width, window.innerHeight/r.height) * 0.7));
  offsetX = window.innerWidth/2 - (cx - offsetX) * (ns/scale);
  offsetY = window.innerHeight/2 - (cy - offsetY) * (ns/scale);
  scale = ns; setTransform();
});

/* =================== modals: view / add =================== */
const viewOverlay = document.getElementById('viewOverlay');
const viewImg = document.getElementById('viewImg');
const viewTitle = document.getElementById('viewTitle');
const viewSub = document.getElementById('viewSub');
document.getElementById('viewClose').onclick = ()=> viewOverlay.classList.remove('on');
viewOverlay.addEventListener('click', e=>{ if(e.target===viewOverlay) viewOverlay.classList.remove('on'); });

const addOverlay = document.getElementById('addOverlay');
const addCancel  = document.getElementById('addCancel');
const addSave    = document.getElementById('addSave');
const drop       = document.getElementById('drop');
const file       = document.getElementById('file');
const preview    = document.getElementById('preview');
const dropText   = document.getElementById('dropText');
const desc       = document.getElementById('desc');
let addRectId = null;

function onTileClick(e){
  const el = e.currentTarget;
  const id = +el.dataset.id;
  const claim = claims[id];
  if (claim){
    viewTitle.textContent = claim.name || 'Member of the Golden Million';
    viewSub.textContent = claim.desc || '“A short line for history.”';
    viewImg.src = claim.img;
    viewOverlay.classList.add('on');
  } else {
    addRectId = id;
    preview.style.display='none'; preview.src=''; dropText.textContent='Drop an image here (or click)'; desc.value='';
    addOverlay.classList.add('on');
  }
}

drop.addEventListener('click', ()=> file.click());
drop.addEventListener('dragover', e=>{ e.preventDefault(); drop.style.borderColor="#999"; });
drop.addEventListener('dragleave', ()=>{ drop.style.borderColor="#cfd3da"; });
drop.addEventListener('drop', e=>{
  e.preventDefault(); drop.style.borderColor="#cfd3da";
  if (e.dataTransfer.files && e.dataTransfer.files[0]) handleFile(e.dataTransfer.files[0]);
});
file.addEventListener('change', e=>{ if (e.target.files && e.target.files[0]) handleFile(e.target.files[0]); });

function handleFile(f){
  if (!/^image\//.test(f.type)) return alert('Please choose an image');
  const r = new FileReader();
  r.onload = ()=>{ preview.src=r.result; preview.style.display='block'; dropText.textContent='Image selected'; };
  r.readAsDataURL(f);
}

addCancel.onclick = ()=> addOverlay.classList.remove('on');
addOverlay.addEventListener('click', e=>{ if(e.target===addOverlay) addOverlay.classList.remove('on'); });

addSave.onclick = async ()=>{
  if (addRectId==null) return;
  if (!preview.src) return alert('Please add an image first.');
  const r = layout.find(x=>x.id===addRectId);
  const compressed = await downscaleToWebP(preview.src, Math.min(r.w, r.h));
  claims[addRectId] = { img: compressed, name:'Golden Million Member', desc:(desc.value||'I was here.').slice(0,80) };
  persist();
  addOverlay.classList.remove('on');
  drawDOM();
};

/* ======= downscale to WebP to avoid storage quota ======= */
function loadImg(src){
  return new Promise((res,rej)=>{ const im=new Image(); im.onload=()=>res(im); im.onerror=rej; im.src=src; });
}
async function downscaleToWebP(dataURL, shortSidePx){
  const im = await loadImg(dataURL);
  const target = Math.max(260, Math.round(shortSidePx*0.9));
  const scale = Math.min(1, target / Math.min(im.width, im.height));
  const w = Math.max(180, Math.round(im.width*scale));
  const h = Math.max(180, Math.round(im.height*scale));
  const c = document.createElement('canvas'); c.width=w; c.height=h;
  const g = c.getContext('2d'); g.imageSmoothingEnabled=true; g.imageSmoothingQuality='high';
  g.drawImage(im, 0,0,w,h);
  let out = c.toDataURL('image/webp', 0.86);
  if (out.length > 4_500_000) out = c.toDataURL('image/jpeg', 0.86);
  return out;
}

/* ===================== boot ===================== */
fillLegends();
drawDOM();
</script>
</body>
</html>
