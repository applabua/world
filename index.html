<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>GOLDEN MILLION — Get in now, be remembered beside legends.</title>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<style>
  :root{ --bg:#fff; --ink:#111; --muted:#6b7280; --line:#e5e7eb; --overlay:rgba(0,0,0,.45); }
  *{box-sizing:border-box}
  html,body{height:100%;margin:0;background:var(--bg);color:var(--ink);font:14px/1.45 system-ui,-apple-system,Segoe UI,Roboto,Arial}
  header{position:fixed;inset:0 0 auto 0;z-index:20;display:flex;justify-content:center;padding:8px 12px;pointer-events:none}
  .cta{pointer-events:auto;display:inline-flex;align-items:center;gap:10px;background:rgba(255,255,255,.96);border:1px solid var(--line);border-radius:999px;padding:8px 14px;box-shadow:0 4px 20px rgba(0,0,0,.06)}
  .dot{width:10px;height:10px;border-radius:50%;background:radial-gradient(#ffd24d,#e1b526)}
  .cta b{font-weight:800}.cta span{color:var(--muted)}
  #field{position:fixed;inset:0;display:block;cursor:grab}
  #field:active{cursor:grabbing}

  .overlay{position:fixed;inset:0;background:var(--overlay);display:none;align-items:center;justify-content:center;z-index:50}
  .overlay.on{display:flex}
  .card{width:min(720px,92vw);background:#fff;border:1px solid var(--line);border-radius:16px;box-shadow:0 10px 40px rgba(0,0,0,.25);padding:16px;animation:pop .26s ease-out both}
  @keyframes pop{from{transform:scale(.96);opacity:0}to{transform:scale(1);opacity:1}}
  .title{margin:0 0 6px 0;font-weight:800;letter-spacing:.3px}
  .sub{margin:0 0 12px 0;color:var(--muted)}
  .row{display:flex;gap:12px;flex-wrap:wrap}.col{flex:1 1 280px}
  .drop{min-height:140px;border:1px dashed #cfd3da;border-radius:12px;display:flex;align-items:center;justify-content:center;color:#666;padding:10px;text-align:center;background:#fafafa;cursor:pointer}
  .thumb{max-width:100%;max-height:340px;border-radius:12px;border:1px solid var(--line);display:block}
  .input{width:100%;padding:10px 12px;border:1px solid var(--line);border-radius:10px}
  .actions{display:flex;gap:8px;justify-content:flex-end;margin-top:14px}
  .btn{appearance:none;border:1px solid var(--line);background:#fff;color:#111;padding:8px 12px;border-radius:10px;cursor:pointer}
  .btn.primary{border-color:#111;background:#111;color:#fff}
  .mini{font-size:12px;color:#666}
</style>
</head>
<body>
<header>
  <div class="cta">
    <div class="dot"></div><b>GOLDEN MILLION</b>
    <span>Get in now — be remembered beside legends.</span>
  </div>
</header>

<canvas id="field"></canvas>

<!-- VIEW (occupied) -->
<div class="overlay" id="viewOverlay">
  <div class="card">
    <h3 class="title" id="viewTitle">Legend</h3>
    <p class="sub" id="viewSub">“A short line for history.”</p>
    <img id="viewImg" class="thumb" alt="">
    <div class="actions"><button class="btn" id="viewClose">Close</button></div>
  </div>
</div>

<!-- ADD (free) -->
<div class="overlay" id="addOverlay">
  <div class="card">
    <h3 class="title">Claim your golden spot — $1 / year (test mode)</h3>
    <p class="sub">Add your image and a short line about yourself. Saved locally in your browser for now.</p>
    <div class="row">
      <div class="col">
        <div class="drop" id="drop">
          <input type="file" id="file" accept="image/*" style="display:none">
          <span id="dropText">Drop an image here (or click)</span>
        </div>
        <img id="preview" class="thumb" alt="" style="display:none;margin-top:8px">
      </div>
      <div class="col">
        <label class="sub" for="desc">Your short line (max 80 chars)</label>
        <input class="input" id="desc" maxlength="80" placeholder="I was here. 2025.">
        <p class="mini">Size of the tile is fixed by the mosaic. Zoom/pan the wall to explore.</p>
      </div>
    </div>
    <div class="actions"><button class="btn" id="addCancel">Cancel</button><button class="btn primary" id="addSave">Save (test)</button></div>
  </div>
</div>

<script>
/* =========================================================
   GOLDEN MILLION — one-file demo with a 1000-piece random tiling
   - 1,000 variable-sized rectangles tile the 1,000,000-cell wall
   - Top-100 largest rectangles are prefilled with “legends” (no Putin)
   - Click occupied → smooth modal; click free → add (stored in localStorage)
   - Images auto-compress to WebP to avoid quota
   - Pan (drag) & Zoom (wheel). Initial view shows the whole wall.
   ========================================================= */

/* ---------- Canvas & world ---------- */
const CAN = document.getElementById('field');
const CTX = CAN.getContext('2d', { alpha:false });
let DPR = Math.max(1, window.devicePixelRatio || 1);

const WORLD_CELLS_W = 1000, WORLD_CELLS_H = 1000; // conceptual 1e6 cells
const CELL = 10; // world cell size in px (before scaling)
const WORLD = { w: WORLD_CELLS_W*CELL, h: WORLD_CELLS_H*CELL };

let W=0,H=0, scale=0.12, offX=0, offY=0;

function fit(){
  W = CAN.width = Math.floor(window.innerWidth * DPR);
  H = CAN.height = Math.floor(window.innerHeight * DPR);
  CAN.style.width = window.innerWidth+'px'; CAN.style.height = window.innerHeight+'px';
  const sFit = Math.min(W/WORLD.w, H/WORLD.h);
  if (!fit._done){ scale = sFit * 1.02; offX = (W - WORLD.w*scale)/2; offY = (H - WORLD.h*scale)/2; fit._done = true; }
  draw();
}
window.addEventListener('resize', fit);

const clamp = (n,a,b)=> Math.max(a, Math.min(b,n));
function worldToScreen(wx,wy){ return [(wx*scale + offX), (wy*scale + offY)]; }
function screenToWorld(sx,sy){ return [(sx - offX)/scale, (sy - offY)/scale]; }

/* ---------- Random TILING into 1000 rectangles ---------- */
function makeRect(x,y,w,h){ return {x,y,w,h, area:w*h}; }
function splitRect(r){
  // prefer splitting along the longer side, but randomize a bit
  const horiz = (r.w >= r.h) ? Math.random() > 0.2 : Math.random() < 0.2;
  if (horiz) {
    const min = Math.max(40, Math.floor(r.w*0.33));
    const max = Math.min(r.w-40, Math.floor(r.w*0.67));
    if (max <= min) return [r];
    const cut = randInt(min, max);
    return [makeRect(r.x, r.y, cut, r.h), makeRect(r.x+cut, r.y, r.w-cut, r.h)];
  } else {
    const min = Math.max(40, Math.floor(r.h*0.33));
    const max = Math.min(r.h-40, Math.floor(r.h*0.67));
    if (max <= min) return [r];
    const cut = randInt(min, max);
    return [makeRect(r.x, r.y, r.w, cut), makeRect(r.x, r.y+cut, r.w, r.h-cut)];
  }
}
function randInt(a,b){ return Math.floor(a + Math.random()*(b-a+1)); }

function buildTiling(targetCount){
  const list = [ makeRect(0,0, WORLD.w, WORLD.h) ];
  while (list.length < targetCount) {
    // pick the largest splittable rect (and avoid crazy aspect ratios)
    let idx=-1, best=-1;
    for (let i=0;i<list.length;i++){
      const r = list[i];
      const aspect = r.w / r.h;
      const splittable = (r.w > 80 && r.h > 80); // keep from becoming too tiny
      if (splittable && r.area > best) { best=r.area; idx=i; }
    }
    if (idx === -1) break;
    const r = list.splice(idx,1)[0];
    const [a,b] = splitRect(r);
    if (b) { a.area=a.w*a.h; b.area=b.w*b.h; list.push(a,b); }
    else   { list.push(r); break; }
  }
  // prevent too skinny rectangles by a few corrective splits
  for (let k=0;k<list.length;k++){
    const r = list[k], aspect = r.w/r.h;
    if (aspect>2.2 || aspect<0.45){
      const [a,b] = splitRect(r);
      if (b){ list.splice(k,1,a,b); k--; }
    }
  }
  // trim/exact count
  while (list.length > targetCount) list.pop();

  // assign ids
  list.forEach((r,i)=> r.id=i);
  return list;
}

let layout = buildTiling(1000);

/* ---------- Local storage of claims ---------- */
const LS_KEY = "golden_million_claims_v4";
let claims = {}; // id -> {img, name, desc}
try{ claims = JSON.parse(localStorage.getItem(LS_KEY)||"{}"); }catch(e){ claims = {}; }
function persist(){ try{ localStorage.setItem(LS_KEY, JSON.stringify(claims)); }catch(e){ alert("Storage quota exceeded. Try a smaller image."); }}

/* ---------- Legends in the largest 100 rectangles ---------- */
const LEGEND_NAMES = [
  "Abraham Lincoln","Nelson Mandela","Mahatma Gandhi","Martin Luther King Jr.","Winston Churchill",
  "Volodymyr Zelenskyy","George Washington","Napoleon Bonaparte","Julius Caesar","Cleopatra",
  "Leonardo da Vinci","Michelangelo","Vincent van Gogh","Pablo Picasso","Frida Kahlo",
  "Albert Einstein","Isaac Newton","Galileo Galilei","Nikola Tesla","Marie Curie",
  "Ada Lovelace","Alan Turing","Grace Hopper","Katherine Johnson","Hedy Lamarr",
  "Charles Darwin","Carl Sagan","Richard Feynman","Johannes Kepler","Niels Bohr",
  "William Shakespeare","Homer","Dante Alighieri","Johann S. Bach","Ludwig van Beethoven",
  "Wolfgang A. Mozart","Leo Tolstoy","Fyodor Dostoevsky","Ernest Hemingway","Agatha Christie",
  "Elon Musk","Steve Jobs","Bill Gates","Jeff Bezos","Warren Buffett",
  "Donald Trump","Barack Obama","Joe Biden","Angela Merkel","Emmanuel Macron",
  "Serena Williams","Michael Jordan","Kobe Bryant","Lionel Messi","Cristiano Ronaldo",
  "Pelé","Usain Bolt","Bruce Lee","Jackie Chan","Hayao Miyazaki",
  "Akira Kurosawa","Steven Spielberg","George Lucas","Quentin Tarantino","James Cameron",
  "Mother Teresa","Florence Nightingale","Yayoi Kusama","Banksy","Salvador Dalí",
  "Socrates","Plato","Aristotle","Confucius","Sun Tzu",
  "Genghis Khan","Alexander the Great","Queen Elizabeth II","Joan of Arc","Catherine the Great",
  "Sheryl Sandberg","Satya Nadella","Sundar Pichai","Tim Cook","Susan Wojcicki",
  "Desmond Tutu","Lech Wałęsa","Václav Havel","Stephen Hawking","Jane Goodall",
  "Neil Armstrong","Yuri Gagarin","Amelia Earhart","J.R.R. Tolkien","George R. R. Martin",
  "J.K. Rowling","Haruki Murakami","Gabriel García Márquez","Oprah Winfrey","Greta Thunberg"
]; // 100

function svgPortrait(name){
  const initials = name.split(/\s+/).map(w=>w[0]).slice(0,2).join('').toUpperCase();
  const esc = s=>encodeURIComponent(s);
  const svg =
`<svg xmlns='http://www.w3.org/2000/svg' width='800' height='800'>
  <defs><linearGradient id='g' x1='0' y1='0' x2='0' y2='1'>
    <stop offset='0%' stop-color='#f9e9a3'/><stop offset='50%' stop-color='#f0d16a'/><stop offset='100%' stop-color='#cda434'/>
  </linearGradient></defs>
  <rect width='100%' height='100%' fill='url(#g)'/>
  <circle cx='400' cy='330' r='180' fill='rgba(255,255,255,.25)'/>
  <text x='400' y='380' font-family='system-ui,Arial' font-size='160' text-anchor='middle' fill='#222' font-weight='800'>${initials}</text>
  <text x='400' y='720' font-family='system-ui,Arial' font-size='42' text-anchor='middle' fill='#222' font-weight='700'>${name.replace(/&/g,"&amp;")}</text>
</svg>`;
  return "data:image/svg+xml;utf8,"+esc(svg);
}

// assign only once (keep your user claims)
(function prefillLegends(){
  const already = Object.values(claims).filter(v=>v && v.legend).length;
  if (already >= LEGEND_NAMES.length) return;
  // sort rectangles by area desc
  const sorted = [...layout].sort((a,b)=>b.area-a.area).slice(0, LEGEND_NAMES.length);
  sorted.forEach((r, i)=>{
    const name = LEGEND_NAMES[i];
    if (!claims[r.id]) claims[r.id] = { img: svgPortrait(name), name, desc: "Part of the Golden Million.", legend: true };
  });
  persist();
})();

/* ---------- Image cache & draw helpers ---------- */
const imgCache = new Map();
function loadImg(src){
  if (imgCache.has(src)) return imgCache.get(src);
  const p = new Promise((res,rej)=>{ const im=new Image(); im.crossOrigin="anonymous"; im.onload=()=>res(im); im.onerror=rej; im.src=src; });
  imgCache.set(src,p); return p;
}
async function drawImageCover(src,x,y,w,h){
  try{
    const im = await loadImg(src);
    const r = Math.max(w/im.width, h/im.height);
    const iw = im.width*r, ih = im.height*r;
    const ix = x + (w - iw)/2, iy = y + (h - ih)/2;
    CTX.fillStyle="#fff"; CTX.fillRect(x,y,w,h);
    CTX.drawImage(im, ix, iy, iw, ih);
  }catch(e){}
}

/* ---------- Irregular border for every tile ---------- */
function beginIrregularRectPath(x,y,w,h,seed){
  const rnd = (k)=>{ let t=(seed||1)*1103515245 + k*12345; t = (t>>>0)/4294967296; return t; };
  const stepsX = Math.max(4, Math.floor(w/120));
  const stepsY = Math.max(4, Math.floor(h/120));
  const j = 12; // jitter px
  CTX.beginPath();
  // top
  for(let i=0;i<=stepsX;i++){
    const px = x + (i/stepsX)*w;
    const py = y + rnd(i)*j;
    (i===0) ? CTX.moveTo(px,py) : CTX.lineTo(px,py);
  }
  // right
  for(let i=1;i<=stepsY;i++){
    const px = x + w - rnd(i+11)*j;
    const py = y + (i/stepsY)*h;
    CTX.lineTo(px,py);
  }
  // bottom
  for(let i=1;i<=stepsX;i++){
    const px = x + w - (i/stepsX)*w;
    const py = y + h - rnd(i+23)*j;
    CTX.lineTo(px,py);
  }
  // left
  for(let i=1;i<=stepsY;i++){
    const px = x + rnd(i+37)*j;
    const py = y + h - (i/stepsY)*h;
    CTX.lineTo(px,py);
  }
  CTX.closePath();
}

/* ---------- Drawing ---------- */
function draw(){
  CTX.setTransform(1,0,0,1,0,0);
  CTX.fillStyle="#fff"; CTX.fillRect(0,0,W,H);

  const [wx0, wy0] = screenToWorld(0,0);
  const [wx1, wy1] = screenToWorld(W,H);

  // Draw only tiles in viewport
  for (const r of layout){
    if (r.x + r.w < wx0 || r.y + r.h < wy0 || r.x > wx1 || r.y > wy1) continue;
    const [sx, sy] = worldToScreen(r.x, r.y);
    const sw = r.w*scale, sh = r.h*scale;

    // content (if claimed)
    const claim = claims[r.id];
    if (claim){
      CTX.save();
      beginIrregularRectPath(sx, sy, sw, sh, r.id*9173);
      CTX.clip();
      awaitOrQueue(drawImageCover(claim.img, sx, sy, sw, sh));
      CTX.restore();
    }

    // outline
    CTX.save();
    CTX.lineWidth = Math.max(1, 0.7*DPR);
    CTX.strokeStyle = '#d0d4dc';
    beginIrregularRectPath(sx, sy, sw, sh, r.id*9173);
    CTX.stroke();
    CTX.restore();
  }
}

let drawQueue = Promise.resolve();
function awaitOrQueue(p){ drawQueue = drawQueue.then(()=>p).catch(()=>{}); }

/* ---------- Hit testing ---------- */
function rectHit(r, sx, sy){
  const [x,y] = worldToScreen(r.x, r.y);
  const w = r.w*scale, h = r.h*scale;
  return sx>=x && sy>=y && sx<=x+w && sy<=y+h;
}
function hitTest(clientX, clientY){
  const sx = clientX * DPR, sy = clientY * DPR;
  // scan from top (last drawn) for better UX, but 1000 rects = ok either way
  for (let i=layout.length-1; i>=0; i--){
    if (rectHit(layout[i], sx, sy)) return layout[i];
  }
  return null;
}

/* ---------- Interactions ---------- */
let dragging=false, sX=0, sY=0, oX=0, oY=0;
CAN.addEventListener('mousedown',e=>{ dragging=true; sX=e.clientX; sY=e.clientY; oX=offX; oY=offY; });
window.addEventListener('mouseup',()=> dragging=false);
window.addEventListener('mousemove',e=>{ if(dragging){ offX = oX + (e.clientX - sX)*DPR; offY = oY + (e.clientY - sY)*DPR; draw(); }});
CAN.addEventListener('wheel',e=>{
  e.preventDefault();
  const delta = Math.sign(e.deltaY)*-0.08;
  const rect = CAN.getBoundingClientRect();
  const cx = (e.clientX-rect.left)*DPR, cy=(e.clientY-rect.top)*DPR;
  const [wx,wy] = screenToWorld(cx,cy);
  scale = clamp(scale+delta, 0.06, 3);
  offX = cx - wx*scale; offY = cy - wy*scale;
  draw();
},{passive:false});

CAN.addEventListener('click', (e)=>{
  const rect = hitTest(e.clientX, e.clientY);
  if (!rect) return;
  const claim = claims[rect.id];
  if (claim) openView(claim);
  else       openAdd(rect);
});

/* ---------- View modal ---------- */
const viewOverlay = document.getElementById('viewOverlay');
const viewImg = document.getElementById('viewImg');
const viewTitle = document.getElementById('viewTitle');
const viewSub = document.getElementById('viewSub');
document.getElementById('viewClose').onclick = ()=> viewOverlay.classList.remove('on');
viewOverlay.addEventListener('click',e=>{ if(e.target===viewOverlay) viewOverlay.classList.remove('on'); });

function openView(rec){
  viewTitle.textContent = rec.name || "Member of the Golden Million";
  viewSub.textContent = rec.desc || "“A short line for history.”";
  viewImg.src = rec.img;
  viewOverlay.classList.add('on');
}

/* ---------- Add modal ---------- */
const addOverlay = document.getElementById('addOverlay');
const addCancel  = document.getElementById('addCancel');
const addSave    = document.getElementById('addSave');
const drop       = document.getElementById('drop');
const file       = document.getElementById('file');
const preview    = document.getElementById('preview');
const dropText   = document.getElementById('dropText');
const desc       = document.getElementById('desc');

let addRect = null;

drop.addEventListener('click', ()=> file.click());
drop.addEventListener('dragover',e=>{ e.preventDefault(); drop.style.borderColor="#999"; });
drop.addEventListener('dragleave',()=>{ drop.style.borderColor="#cfd3da"; });
drop.addEventListener('drop',e=>{
  e.preventDefault(); drop.style.borderColor="#cfd3da";
  if (e.dataTransfer.files && e.dataTransfer.files[0]) handleFile(e.dataTransfer.files[0]);
});
file.addEventListener('change',e=>{ if (e.target.files && e.target.files[0]) handleFile(e.target.files[0]); });

function handleFile(f){
  if(!/^image\//.test(f.type)) return alert("Please choose an image");
  const r=new FileReader(); r.onload=()=>{ preview.src=r.result; preview.style.display='block'; dropText.textContent="Image selected"; }; r.readAsDataURL(f);
}

addCancel.onclick = ()=> addOverlay.classList.remove('on');
addOverlay.addEventListener('click',e=>{ if(e.target===addOverlay) addOverlay.classList.remove('on'); });

function openAdd(r){
  addRect = r;
  preview.style.display='none'; preview.src=''; dropText.textContent="Drop an image here (or click)";
  desc.value="";
  addOverlay.classList.add('on');
}

addSave.onclick = async ()=>{
  if (!addRect) return;
  if (!preview.src) return alert("Please add an image first.");
  const compressed = await downscaleToWebP(preview.src, Math.min(addRect.w, addRect.h));
  claims[addRect.id] = { img: compressed, name: "Golden Million Member", desc: (desc.value||"I was here.").slice(0,80) };
  persist();
  addOverlay.classList.remove('on');
  draw();
};

/* Downscale to WebP proportional to tile size (keeps storage small) */
async function downscaleToWebP(dataURL, tileShortSidePx){
  const img = await loadImg(dataURL);
  // Target ~ 80px per 100px of tile short side in world space
  const base = Math.max(200, Math.round(tileShortSidePx * 0.8));
  const scale = Math.min(1, base / Math.min(img.width, img.height));
  const w = Math.max(80, Math.round(img.width * scale));
  const h = Math.max(80, Math.round(img.height * scale));
  const c = document.createElement('canvas'); c.width=w; c.height=h;
  const g = c.getContext('2d'); g.imageSmoothingEnabled=true; g.imageSmoothingQuality='high';
  g.drawImage(img, 0,0,w,h);
  let out = c.toDataURL('image/webp', 0.85);
  if (out.length > 4_500_000) out = c.toDataURL('image/jpeg', 0.85);
  return out;
}

/* ---------- Init ---------- */
fit(); draw();
</script>
</body>
</html>
